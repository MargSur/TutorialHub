# Инструкция для работы с **Git** и удалёнными репозиториями

## Что такое **Git**?
*Git* - это одна из реализаций распределённых систем контроля версий, имеющая как и локальные, так и удалённые репозитории. Является самой популярной реализацией систем контроля версий в мире.

## *Подготовка репозитория*
Для создания репозитория необходимо выполнить команду *git init*  в папке с репозиторием и у Вас создаться репозиторий **(появится скрытая папка .git)**. _(см. скрин ниже)_
![Пример](git%20init.png)

## Создание коммитов

***

### Git add
>Для **добавления** измений в коммит используется команда **git add**. 

>Чтобы использовать команду *git add* напишите *git add <имя файла>*

---

### Просмотр состояния *репозитория*
Для того, чтобы посмотреть состояние репозитория используется команда *git status*. Для этого необходимо в папке с репозиторием написать *git status*, и Вы увидите: 
* были ли изменения в файлах
* или их не было.


### Нумерованный список
> Чтобы создать нумерованный список, можно использовать все единицы. При публикации числа отображаются в возрастающем порядке в виде последовательного списка. Для повышения удобства чтения исходного кода списки можно вводить с приращением вручную.

Например,
1. Это
1. родительский нумерованный список,
   1. *а это*
   1. *вложенный нумерованный список*
1. Конец

### Маркированный список
> Для создания маркированного списка используйте - или *, за которым следует пробел в начале каждой строки

Например, 
- Это
- родительский маркированный список,
   * *а это*
   * *вложенный маркирвоанный список*
- **Конец**

***

### **Создание коммитов**
Для того, чтобы создать коммит(сохранение) необходимо выполнить команду *git commit*. Выполняется она так: *git commit -m "<сообщение к коммиту>*. Все файлы для коммита должны быть ***ДОБАВЛЕНЫ*** и сообщение к коммиту писать ***ОБЯЗАТЕЛЬНО***. (см. по [ссылке](https://rukeba.com/by-the-way/markdown-sintaksis-po-russki/))
 
***

 ## **Перемещение между сохранениями**
> _Для того, чтобы **перемещаться** между коммитами_, используется команда **git checkout**. Используется она в папке с репозиторием следующим образом: *git checkout <номер коммита>*
> Для того, чтобы перемещаться между коммитами, используется команда *git checkout*. Используется она в папке с репозиторием следующим образом: *git checkout <номер коммита>*

# Создание веток в **Git**

## Что делает git branch
Команда **git branch** — _главный __инструмент__ для работы с ветвлением_. С ее помощью можно *добавлять новые ветки*, _перечислять и переименовывать_ существующие и *удалять* их.


## Способы создания веток и переключения между ними
Чтобы в Git добавить **ветку** мы используем git branch _name of new branch_
После данной операции ветка уже была создана, но вы по-прежнему находитесь в прежней ветке. 

Если вы планируете переместиться на другую ветку, в том числе только что созданную, необходимо написать __checkout__ следующим образом: git checkout _name of branch_

***

## Как закоммитить изменения в новую ветку
>После создания новой ветки, перехода в нее и совершения всех запланированных преобразований, нужно сделать коммит в эту же ветку, чтобы сохранить все изменения. Команды для выполнения этих действий ничем не отличаются от команд для создания коммитов в ветке мастер.

Пошагово:
1. __git add *__
2. __git commit -m *"information about commit"*__

>> После выполнения последовательности этих команд мы закоммитили изменения в нужной версии программы.

***

## Основы ветвления и слияния
Ветвление позволяет разделять рабочий процесс, оптимизировать тестирование и написание нового кода. Однако после того, как разработчик убедился, что написанный им кусок кода готов и его можно отправить к остальной части итоговой версии, удобно переместить его в основную ветку. Такой подход дает возможность получить к концу разработки проекта целый продукт в одном месте.
Для этого в Git предусмотрено слияние — перенос изменений с одной ветки на другую. Однако сливаемая ветка (под этим определением мы подразумеваем ветку, у которой берем изменения для «вливания» их в другую ветвь) никак не меняется и остается в прежнем состоянии. 

> Такие преобразования мы получаем, применив git merge _name of merged branch_

>> Операция может привести к появлению **конфликтов** при попытке слить ветки. Это вызвано тем, что изменения удаляют или переписывают информацию в существующих файлах. При попытке некорректного слияния _Git_ останавливает выполнение команды, чтобы вы могли разрешить конфликт.

               Решить конфликт можно двумя способами:

- Вручную разрешить файловый конфликт. Для этого нужно самим изменить файлы, с которыми возникли проблемы. Мы получим файлы такими, какими и представляли их при попытке слияния.
- Выбрать более подходящий файл, а от второго отказаться.

***

# __Удаленный репозиторий__

## 1. Как подключиться к удаленному репозитарию? 
Для загрузки данных в удаленный репозитарию сначала нужно к нему _подключиться_.
 Для того, чтобы связать созданный нами локальный репозитарий с удаленным, выполним такую команду: 
 __git remote add origin *URL*__
 ## 2. Как отправить изменения в удаленный репозитарий?
Теперь, когда у нас в локальном репозитарии создан коммит и мы подключились к удаленному, можем отправить его на сервер. Мы это будем делать каждый раз, когда хотим обновить данные в удаленном репозитарии.
Отправка коммита осуществляется с помощью команды __push__, которая имеет два параметра - имя удаленного репозитория (в нашем случае origin) и ветку, в которую необходимо внести изменения (master — это ветка по умолчанию для всех репозиториев).
## 3. Как клонировать удаленный репозитарий?
Если у других пользователей возникла необходимость клонировать удаленный репозитарий, они могут получить полностью работоспособную копию при помощи команды **clone**:
 _**git clone** URL_
 ## 4. Как запросить изменения с удаленного репозитария?
В случае, если другим пользователям нет необходимости делать клон удаленного репозитария, а нужно просто получить информацию об изменениях, это можно сделать с помощью команды pull: _**git pull origin master**_